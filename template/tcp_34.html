<h3>tcp的三次握手和四次挥手</h3>
<ul>
    <h3>三次握手</h3>
    <ul>
    <li>
        第一次握手：<br>
        起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
    </li>
    <li>
        第二次握手：<br>
        Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态
    </li>
    <li>第三次握手：<br>
        TCP客户进程收到B的确认后，要向B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）。
    </li>
        <li>
            <p>三次握手示意图</p>
            <img src = 'img/tcp_1.png'>
        </li>    
    </ul>
    <h4>四次挥手</h4>
    <ul>
         <li>第一次挥手: 主动关闭方发送一个Fin,用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再
        给你发数据了。
    （当然，在fin包之前发送出去的数据，如果没有收到ack确认报文，主动关闭方依然会重发这些数据），但是，此时主动关闭方还可
    以接收数据。</li>
        <li>第二次挥手：被动关闭方收到Fin包后，发送一个ACK给对方，确认收到序号+1；</li>
         <li>第三次挥手：被动关闭方发送一个Fin,用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，数据发送完成</li>
        <li>第四次挥手：主动关闭方收到Fin后，发送一个ACK给被动关闭方，确认序号为收到序号+1。</li>
        <li>
            <p>四次挥手示意图</p>
            <img src = 'img/tcp_2.png'>
        </li> 
    </ul>
</ul>

<h3>tcp连接三次握手过程？为什么要采用三次握手，两次握手可以吗？</h3>
<ul>
    <li>（1）客户端向服务器发送连接请求，服务器对客户段的报文进行确认，服务器在对客户端的确认进行确认。</li>
    <li>（2）采用三次握手是<b>为了防止失效的连接请求报文段又突然传给服务器</b>,因而产生错误。</li>
</ul>
